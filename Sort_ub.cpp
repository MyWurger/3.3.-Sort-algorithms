#include "Sort_ub.h"    // подключаем заголовочный файл с прототипами алгоритмов сортировки по убыванию
#include <iostream>     // стандартные потоки ввода/вывода
// в такой реализации Quick_sort даёт переполнение стека из-за глубины рекурсии. Увеличиваем его размер
#pragma comment(linker, "/STACK:2666777216")

/***************************************************/
/*             РЕАЛИЗАЦИЯ ФУНКЦИЙ                  */
/***************************************************/

// СОРТИРОВКИ МАССИВА ПО УБЫВАНИЮ:
/*-----------------------------------------------------------*/
/* Шейкерная сортировка по убыванию           */
/*--------------------------------------------*/
void Shaker_sort_ub(int* pznachenue        // указатель на первый элемент динамического массива-вектора
	              , int begin              // начало динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	              , int end                // конец динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	              , int number)            // длина динамического массива-вектора  
{
	int i;                                 // для прохода по всем элементам массива
	int Temp;                              // для промежуточного сохранения элемента замены
	// пока массив не <схлопнулся>
	while (begin <= end)
	{
		// проходим по неотсортированной части из конца в начало.
		for (i = end; i > begin; i--)
		{
			if (pznachenue[i] > pznachenue[i - 1]) // если текущий больше предыдущего
			{
				// перемещаем его на позицию предыдущего
				Temp = pznachenue[i - 1];          // сохраняем предыдущий в промежуточную переменную
				pznachenue[i - 1] = pznachenue[i]; // помещаем на его место текущий элемент
				pznachenue[i] = Temp;              // на место текущего: значение меньшего-сохранённого
			}// if (pznachenue[i] > pznachenue[i - 1])
		}// for i
		begin = begin + 1;                   // самый маленький элемент массива встал на своё место --> уменьшаем рассматриваемый диапазон. Сдвигаем начало

		// проходим по неотсортированной части из начала в конец
		for (i = begin; i < end; i++)
		{
			if (pznachenue[i] < pznachenue[i + 1])  // если текущий меньше следующего
			{
				// перемещаем его на позицию следующего
				Temp = pznachenue[i + 1];           // сохраняем следующий в промежуточную переменную
				pznachenue[i + 1] = pznachenue[i];  // помещаем на его место текущий элемент
				pznachenue[i] = Temp;               // на место текущего; значение меньшего-сохранённого
			}// if (pznachenue[i] < pznachenue[i + 1])
		}// for i
		end = end - 1;                     // самый большой элемент массива встал на своё место --> уменьшаем рассматриваемый д
	}// while (begin <= end)
	return;                               // возвращаем обещанное значение в caller           
}// Shaker_sort_ub()


/*-----------------------------------------------------------*/
/* сортировка выбором  по убыванию            */
/*--------------------------------------------*/
void Selection_sort_ub(int* pznachenue     // указатель на первый элемент динамического массива-вектора
	                 , int begin           // начало динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	                 , int end             // конец динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	                 , int number)         // длина динамического массива-вектора  
{
	int Max;                                 // максимальный элемент
	int jMax;                                // индекс максимального элемента
	int iSort;                               // граница отсортированной области
	int i, j;                                // счётчики
	int Temp;                                // для обмена

	for (iSort = 0; iSort < number - 1; iSort++)   // пока не дошли до конца
	{
		// первый элемент из неупорядоченных назначаем максимальным. С УЧЁТОМ ПЕРЕДАЧИ АДРЕСА на первый элемент в функцию
		Max = *(pznachenue + iSort);               // максимум
		jMax = iSort;                              // его индекс

		// ищем максимальный элемент в оставшейся части массива
		for (j = iSort + 1; j < number; j++)
		{
			if (*(pznachenue + j) > Max)           // очередной кандидат на максимальный
			{
				// запоминаем максимальный элемент и его номер
				Max = *(pznachenue + j);
				jMax = j;
			}// if (*(pznachenue + j) > Max) 
		}// for j

		// нашли максимум в неупорядоченной части массива
		// ставим его на место первого в неупорядоченной части массива
		// меняем элементы местами
		Temp = *(pznachenue + iSort);
		*(pznachenue + iSort) = *(pznachenue + jMax);
		*(pznachenue + jMax) = Temp;
	}// for iSort
	return;                                        // вернули обещанное значение
}// Selection_sort_ub()


/*-----------------------------------------------------------*/
/* сортировка вставками по убыванию            */
/*---------------------------------------------*/
void Insertion_sort_ub(int* pznachenue     // указатель на первый элемент динамического массива-вектора
	                 , int begin           // указатель на первый элемент динамического массива-вектора
	                 , int end             // конец динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	                 , int number)         // длина динамического массива-вектора                 
{
	int i;                                 // для прохода в цикле
	int key;                               // для хранения перемещаемого элемента
	int j;                                 // для прохода в цикле
	// идём с начала до конца
	for (i = 1; i < number; i++)
	{
		key = pznachenue[i];               // запоминаем элемент, который будем перемещать
		j = i - 1;                         // работаем с той частью, которая находится до перемещаемого элемента
		// идём по этой части с конца в начало - перемещаем элементы в соответствии с их отношением к ключу
		// если в части до ключа элементы, меньшие его
		while (j >= 0 && pznachenue[j] < key)
		{
			// сдвигаем элементы до тех пор, пока следующий не будет больше ключа
			// ставим на место следующего элемента(для конца части - на место первого) элемент, меньший ключа
			pznachenue[j + 1] = pznachenue[j];
			j = j - 1;                     // сдвигаемся по части, находящейся до ключа
		}// while (j >= 0 && pznachenue[j] < key)
		pznachenue[j + 1] = key;           // ставим на новое место запомненный элемент - ключ
	}// for i
	return;                                // вернули обещанное значение в caller
}// Insertion_sort_ub()


/*-----------------------------------------------------------*/
/* сортировка слиянием по убыванию             */
/*---------------------------------------------*/
void Merge_sort_ub(int* pznachenue         // указатель на первый элемент динамического массива-вектора
	             , int begin               // начало динамического массива-вектора
	             , int end                 // конец динамического массива-вектора
	             , int number)             // длина динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
{
	int middle;                            // отталкиваться будем от середины каждой части, разделяя массив на 2 подмассива
	// если осталось по одному элементу в каждом подмассиве
	// базовое условие
	if (begin >= end)
	{
		return;                            // вернулись на шаг назад в caller, где в рассматриваемой части 2 элемента минимум
	}// if(begin >= end)
	middle = (begin + end) / 2;            // вычислили средний элемент для текущего подмассива
	Merge_sort_ub(pznachenue, begin, middle, number);   // сортировка левой части
	Merge_sort_ub(pznachenue, middle + 1, end, number); // сортировка правой части
	Merge_ub(pznachenue, begin, middle, end);           // слияние двух частей
}// Merge_sort_ub()


/*----------------------------------------------------------------------------------*/
/* "Влавствование" - сливание массивов для Merge_sort_ub           */
/*-----------------------------------------------------------------*/
void Merge_ub(int* pznachenue              // указатель на первый элемент динамического массива-вектора
	        , int begin                    // начало динамического массива-вектора
	        , int middle                   // середина динамического массива-вектора
	        , int end)                     // конец динамического массива-вектора
{
	// соединение начинается с самых маленьких подмассивов в порядке рекурсии
	int i;                                 // для цикла
	int j;                                 // для цикла
	int k;                                 // для цикла
	int dlB = middle - begin + 1;          // длина левой части подмассива
	int dlC = end - middle;                // длина правой части подмассива
	int* B = NULL;                         // объявляем указатель на динамический массив элементов левой части. Инициализируем его, чтобы не был диким
	B = new int[dlB + 1];                  // создаём динамический подмассив, хранящий элементы левой части исходного
	int* C = NULL;                         // объявляем указатель на динамический массив элементов правой части. Инициализируем его, чтобы не был диким
	C = new int[dlC + 1];                  // создаём динамический подмассив, хранящий элементы правой части исходного
	j = 0;                                 // начинаем заполнять с начала
	// заполняем левую часть
	// для B выделено j, т.к не обязательно begin=0
	for (i = begin; i <= middle; i++)
	{
		B[j] = pznachenue[i];              // элемент левой части - элемент переданного подмассива 
		j++;                               // перемещаемся по подмассиву
	}// for i
	j = 0;                                 // обнулили счётчик для работы с подмассивом C

	// заполняем правую часть
	// для C выделено j, т.к  middle+1!=0
	for (i = middle + 1; i <= end; i++)
	{
		C[j] = pznachenue[i];              // элемент правой части - элемент переданного подмассива 
		j++;                               // перемещаемся по подмассиву
	}// for i

	B[dlB] = INT_MIN;                      // на последнее место каждого массива ставим заведомо меньший элемент,
	C[dlC] = INT_MIN;                      // чтобы не допускать выхода за пределы массива
	i = 0;                                 // ставим все счётчики в начало массивов
	j = 0;
	for (k = begin; k <= end; k++)         // идём по подмассиву
	{
		// выстраиваем иерархию элементов правой и левой части
		if (B[i] >= C[j])                  // если элемент правой части меньше или равен элементу левой части 
		{
			pznachenue[k] = B[i];          // помещаем элемент из левой части на текущее место подмассива
			i = i + 1;                     // перешли к следующему элементу левой части
			// если будет INT_MIN, то левая часть выходит из рассмотрения
		}
		else                               // если элемент левой части меньше элемента правой части             
		{
			pznachenue[k] = C[j];          // помещаем элемент из правой части на текущее место подмассива
			j = j + 1;                     // перешли к следующему элементу правой части
			// если будет INT_MIN, то правая часть выходит из рассмотрения
		}// if (B[i] >= C[j])
	}// for k
	delete[]B;                             // подмассивы отработаны - уничтожаем их
	delete[]C;
	return;                                // вернули обещанное значение в caller
}// Merge_ub()


/*-----------------------------------------------------------*/
/*   быстрая сортировка по убыванию            */
/*---------------------------------------------*/
void Quick_sort_ub(int* pznachenue         // указатель на первый элемент динамического массива-вектора
	             , int begin               // начало динамического массива-вектора
	             , int end                 // конец динамического массива-вектора
	             , int number)             // длина динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве 
{
	int middle;                            // для элемента отталкивания
	// если осталось по одному элементу в каждом подмассиве
	// базовое условие
	if (begin >= end)
	{
		return;                            // вернулись на шаг назад в caller, где в рассматриваемой части 2 элемента минимум
	}
	// переставляем элементы по оси
	middle = Partition_ub(pznachenue, begin, end);
	// работаем с подмассивом, содержащем элементы, большие опорной точки
	Quick_sort_ub(pznachenue, begin, middle - 1, number);
	// работаем с подмассивом, содержащем элементы, меньшие опорной точки
	Quick_sort_ub(pznachenue, middle + 1, end, number);
}// Quick_sort_ub()


/*----------------------------------------------------------------------------*/
/*   разделение и перестановка для Quick_sort_ub          */
/*--------------------------------------------------------*/
int Partition_ub(int* pznachenue           // указатель на первый элемент динамического массива-вектора
	           , int begin                 // начало динамического массива-вектора
	           , int end)                  // конец динамического массива-вектора
{
	// элементы, меньшие точки опоры, будут перемещены вправо от index
	// элементы, большие точки опоры, будут перемещены влево от index
	// равные элементы могут идти в любом направлении
	int index = begin;
	int i;                                 // для циклов
	int Temp;                              // для замены
	// идём в данном подмассиве с начала подмассива в его конец
	for (i = begin; i < end; i++)
	{
		// если нашли элемент, больший или равный опорному (кравний правый)
		if (pznachenue[i] >= pznachenue[end])
		{
			// поместили элемент перед опорной точкой
			Temp = pznachenue[i];
			pznachenue[i] = pznachenue[index];
			pznachenue[index] = Temp;
			index = index + 1;              // index увеличивается
		}// if (pznachenue[i] >= pznachenue[end])
	}// for i
	// поменяли местами опорный и index элементы
	Temp = pznachenue[end];
	pznachenue[end] = pznachenue[index];
	pznachenue[index] = Temp;
	return(index);                          // вернули индекс опорного элемента в caller
}//Partition_ub()


/*-----------------------------------------------------------*/
/*   сортировка Шелла по убыванию              */
/*---------------------------------------------*/
void Shell_sort_ub(int* pznachenue         // указатель на первый элемент динамического массива-вектора
	             , int begin               // начало динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	             , int end                 // конец динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	             , int number)             // длина динамического массива-вектора
{
	int i;                                 // для цикла
	int j;                                 // для цикла
	int Temp;                              // для замены
	int d;                                 // ширина интервала
	d = number / 2;                        // изначально ширина между элементами одной группы - половина массива
	// рассматриваем каждый раз элементы через уменбшающиеся интеравалы, пока не дойдём до рассмотрения каждого друг с другом
	while (d > 0)
	{
		for (i = 0; i < number - d; i++)   // идём по количеству пар
		{
			j = i;                         // пары начинаем с конца рассматриваемой части
			// будем идти с увеличением i по каждой паре, захватывая всё большее количество элементов
			while (j >= 0)
			{
				if (pznachenue[j] < pznachenue[j + d])  // рассматриваем текущий и следующий в интеравале
				{
					// если текущий элемент, меньше следующего из этого интевала
					// меняем местами
					Temp = pznachenue[j];
					pznachenue[j] = pznachenue[j + d];
					pznachenue[j + d] = Temp;
				}// if (pznachenue[j] < pznachenue[j + d])
				j--; // верулись к предыдущему, идем с шагом назад
			}// while j
		}// for i
		d = d / 2;   // уменьшили интервал
	}// while d                                       
	return;          // вернули обещанное значение в caller
}// Shell_sort_ub()