#include "Sort_podr.h"; // подключаем заголовочный файл с прототипами подробных алгоритмов сортировки по возрастанию
#include <iostream>     // стандартные потоки ввода/вывода
// в такой реализации Quick_sort даёт переполнение стека из-за глубины рекурсии. Увеличиваем его размер
#pragma comment(linker, "/STACK:2666777216")

using namespace std;    // используем пространство имён std

/***************************************************/
/*             РЕАЛИЗАЦИЯ ФУНКЦИЙ                  */
/***************************************************/

// ПОДРОБНЫЕ СОРТИРОВКИ МАССИВА ПО ВОЗРАСТАНИЮ:
/*---------------------------------------------------------------------*/
/* подробная Шейкерная сортировка по возрастанию */
/*-----------------------------------------------*/
void Shaker_sort_podr(int* pznachenue      // указатель на первый элемент динамическогомассива-вектора
	                , int begin            // начало динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	                , int end              // конец динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	                , int number)          // длина динамического массива-вектора
{
	int sravnenue;                         // число необходимых сравнений
	int peresulka;                         // число пересылок
	int j;                                 // для вывода массива на экран
	int i;                                 // для прохода по всем элементам массива
	int Temp;                              // для промежуточного сохранения элемента замены

	sravnenue = 0;                         // изначально ничего не сравниваем
	peresulka = 0;                         // изначально нет пересылок
	// пока массив не <схлопнулся>
	while (begin <= end)
	{
		// когда массив уже отсортирован, то не будем выводить
		if (begin < end)
		{
			cout << "\x1b[36mПроход вправо:\x1b[30m \n";
		}// if (begin < end)

		// проходим по неотсортированной части из начала в конец
		for (i = begin; i < end; i++)
		{
			sravnenue = sravnenue + 1;      // увеличили число сравнений
			// выводим после каждого шага
			for (j = 0; j < number; j++)
			{
				// смотрим текущий элемент сортировки и следующий. Подкрашиваем их
				if (j == i)
				{
					cout << "\x1b[31m" << pznachenue[j] << " \x1b[30m";
					cout << "\x1b[36m" << pznachenue[j + 1] << " \x1b[30m";
					j++;                     // перескакиваем следующий элемент, который подкрашен
				}
				// все остальные - обычные
				else
				{
					cout << pznachenue[j] << " ";
				}// if (j==i)
			}//for j
			cout << "\n";
			// если текущий больше следующего
			if (pznachenue[i] > pznachenue[i + 1])
			{
				peresulka = peresulka + 1;    // считаем число пересылок
				// перемещаем его на позицию следующего
				Temp = pznachenue[i + 1];            // сохраняем следующий в промежуточную переменную
				pznachenue[i + 1] = pznachenue[i];   // помещаем на его место текущий элемент
				pznachenue[i] = Temp;                // на место текущего: значение меньшего-сохранённого
				// далее опять сравниваем заменённый со следующим
			}// if (pznachenue[i] > pznachenue[i + 1])
		}// for i
		// учли каждое присвоение, когда менять не нужно
		end = end - 1;      // самый большой элемент массива встал на своё место --> уменьшаем рассматриваемый диапазон. Сдвигаем конец

		// когда массив уже отсортирован, то не будем выводить
		if (begin < end)
		{
			cout << "\x1b[35mПроход влево:\x1b[30m \n";
		}// if (begin < end)

		// проходим по неотсортированной части из конца в начало.
		for (i = end; i > begin; i--)
		{
			sravnenue = sravnenue + 1;                // увеличили число сравнений
			// выводим после каждого шага
			for (j = 0; j < number; j++)
			{
				// смотрим текущий элемент сортировки и предыдущий. Подкрашиваем их
				if (j == i)
				{
					cout << "\x1b[31m" << pznachenue[j] << " \x1b[30m";
				}
				else if (j == i - 1)
				{
					cout << "\x1b[36m" << pznachenue[j] << " \x1b[30m";
				}
				// все остальные - черные
				else
				{
					cout << pznachenue[j] << " ";
				}// if (j == i)
			}//for j
			cout << "\n";
			// если текущий меньше предыдущего
			if (pznachenue[i] < pznachenue[i - 1])
			{ 
				peresulka = peresulka + 1;          // считаем число пересылок
				Temp = pznachenue[i - 1];           // сохраняем предыдущий в промежуточную переменную
				pznachenue[i - 1] = pznachenue[i];  // помещаем на его место текущий элемент
				pznachenue[i] = Temp;               // на место текущего: значение большего-сохранённого
			}// if (pznachenue[i] < pznachenue[i - 1])
		}// for i
		begin = begin + 1;                          // самый маленький элемент массива встал на своё место --> уменьшаем рассматриваемый диапазон. Сдвигаем начало
	}// while (begin <= end)
	cout << "Количесвто сравнений: " << sravnenue << endl;
	cout << "Количество пересылок: " << peresulka << endl;
	return;                                         // возвращаем обещанное значение в caller
}// Shaker_sort_podr()


/*-----------------------------------------------------------------*/
/* подробная сортировка выбором  по возрастанию */
/*----------------------------------------------*/
void Selection_sort_podr(int* pznachenue      // указатель на первый элемент динамическогомассива-вектора
	                   , int begin            // начало динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	                   , int end              // конец динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	                   , int number)          // длина динамического массива-вектора
{
	int sravnenue;                            // число необходимых сравнений
	int peresulka;                            // число пересылок
	int Min;                                  // минимальный элемент
	int jMin;                                 // индекс минимального элемента
	int iSort;                                // граница отсортированной области
	int i, j;                                 // счётчики
	int Temp;                                 // для обмена

	sravnenue = 0;                            // изначально ничего не сравниваем
	peresulka = 0;                            // изначально нет пересылок
	for (iSort = 0; iSort < number - 1; iSort++)   // пока не дошли до конца
	{
		// первый элемент из неупорядоченных назначаем минимальным. С УЧЁТОМ ПЕРЕДАЧИ АДРЕСА на первый элемент в функцию
		Min = *(pznachenue + iSort);               // минимум
		jMin = iSort;                              // его индекс

		// ищем минимальный элемент в оставшейся части массива
		for (j = iSort + 1; j < number; j++)
		{
			sravnenue = sravnenue + 1;             // увеличили число сравнений
			if (*(pznachenue + j) < Min)           // очередной кандидат на минимальный
			{
				// запоминаем минимальный элемент и его номер
				Min = *(pznachenue + j);
				jMin = j;
			}// if(*(pznachenue + j) < Min)
		}// for j

		// Выводим номер прохода
		cout << "\nПроход " << iSort + 1 << ": \n";
		//каждый проход подкрашиваем ту часть массива, которая уже отсортирована
		for (i = 0; i < iSort; i++)
		{
			cout << "\x1b[32m" << pznachenue[i] << " \x1b[30m";
		}// for i
		// в неотсортированной части
		for (i = iSort; i < number; i++)
		{
			// подкрашиваем ключ, с которым сравниваем элементы из неотсортированной части
			if (pznachenue[i] == pznachenue[iSort])
			{
				cout << "\x1b[36m" << pznachenue[iSort] << " \x1b[30m";
			}
			// подкрашиваем элемент, меньший ключа, из неотсортированной части
			else if (pznachenue[i] == pznachenue[jMin])
			{
				cout << "\x1b[31m" << pznachenue[i] << " \x1b[30m";
			}
			// остальные элементы просто выводим
			else
			{
				cout << pznachenue[i] << " ";
			}// if (pznachenue[i] == pznachenue[iSort])
		}//for i
		cout << "\n";
		// нашли минимум в неупорядоченной части массива
		// ставим его на место первого в неупорядоченной части массива
		// меняем элементы местами
		// не учитываем случай, когда элемент не переставляют
		 if (jMin != iSort)
		{
			// увеличили количество пересылок
			peresulka = peresulka + 1;
		}// if (jMin != iSort) 
		Temp = *(pznachenue + iSort);
		*(pznachenue + iSort) = *(pznachenue + jMin);
		*(pznachenue + jMin) = Temp;
	}// for iSort
	cout << "Количество сравнений: " << sravnenue << endl;
	cout << "Количество пересылок: " << peresulka << endl;
	return;                                      // вернули обещанное значение в caller
}// Selection_sort_podr()


/*----------------------------------------------------------------------*/
/*  подробная сортировка вставками по возрастанию   */
/*--------------------------------------------------*/
void Insertion_sort_podr(int* pznachenue      // указатель на первый элемент динамическогомассива-вектора
	                   , int begin            // начало динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	                   , int end              // конец динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	                   , int number)          // длина динамического массива-вектора
{
	int sravnenue;                            // число необходимых сравнений
	int peresulka;                            // число пересылок
	int i;                                    // для прохода в цикле
	int key;                                  // для хранения перемещаемого элемента
	int j;                                    // для прохода в цикле
	int k;                                    // для печати массива на экран  

	sravnenue = 0;                            // изначально ничего не сравниваем
	peresulka = 0;                            // изначально нет пересылок
	// идём с начала до конца
	for (i = 1; i < number; i++)
	{
		key = pznachenue[i];                  // запоминаем элемент, который будем перемещать
		j = i - 1;                            // работаем с той частью, которая находится до перемещаемого элемента
		for (k = 0; k < number; k++)
		{
			// подсвечиваем текущий элемент для вставки красным
			if (k == i)
			{
				cout << "\x1b[31m" << pznachenue[k] << " \x1b[30m";
			}
			// подсвечиваем ту часть массива, куда его будем вставлять
			else if (k < i)
			{
				cout << "\x1b[32m" << pznachenue[k] << " \x1b[30m";
			}
			// все остальные элементы просто выводим
			else
			{
				cout << pznachenue[k] << " ";
			}// if (k == i)
		}// for k
		cout << "\n";
		// идём по этой части с конца в начало - перемещаем элементы в соответствии с их отношением к ключу
		// если в части до ключа элементы, большие его
		// учитываем возможные дыры в сравнениях
		if (pznachenue[i] <= key)
		{
			sravnenue = sravnenue + 1;        // увеличили число сравнений
		}//if (pznachenue[i] <= key) 
		while (j >= 0 && pznachenue[j] > key)
		{
			sravnenue = sravnenue + 1;          // увеличили число сравнений
			peresulka = peresulka + 1;          // увеличили количество пересылок
			// сдвигаем элементы до тех пор, пока следующий не будет меньше ключа
			// ставим на место следующего элемента(для конца части - на место первого) элемент, больший ключа
			pznachenue[j + 1] = pznachenue[j];
			// выводим массив после копирования очередного элемента
			for (k = 0; k < number; k++)
			{
				// подсвечиваем место текущего элемента для вставки красным
				if (k == i)
				{
					cout << "\x1b[31m" << pznachenue[k] << " \x1b[30m";
				}
				// подсвечиваем ту часть массива, куда его будем вставлять
				else if (k < i)
				{
					cout << "\x1b[32m" << pznachenue[k] << " \x1b[30m";
				}
				// все остальные элементы просто выводим
				else
				{
					cout << pznachenue[k] << " ";
				}// if (k == i)
			}// for k
			cout << "\t -- скопировали элемент  " << pznachenue[j] << "\n";
			cout << "\n";
			j = j - 1;                         // сдвигаемся по части, находящейся до ключа
		}// while (j >= 0 && pznachenue[j] > key)
		// ставим на новое место запомненный элемент - ключ
		// если замены были
		if (j != i - 1)
		{
			peresulka = peresulka + 1;             // увеличили количество пересылок
		}
		pznachenue[j + 1] = key;
		// вывод массива после вставки ключа на своё место
		for (k = 0; k < number; k++)
		{
			// подсвечиваем место текущего элемента для вставки красным
			if (k == i)
			{
				cout << "\x1b[31m" << pznachenue[k] << " \x1b[30m";
			}
			// подсвечиваем ту часть массива, куда его будем вставлять
			else if (k < i)
			{
				cout << "\x1b[32m" << pznachenue[k] << " \x1b[30m";
			}
			// все остальные элементы просто выводим
			else
			{
				cout << pznachenue[k] << " ";
			}//if (k == i)
		}// for k
		cout << "\t -- поставили ключ " << key << " на своё место\n";
	}// for i
	cout << "Количество сравнений: " << sravnenue << endl;
	cout << "Количество пересылок: " << peresulka << endl;
	return;                                     // вернули обещанное значение в caller
}// Insertion_sort_podr ()


/*----------------------------------------------------------------- */
/* подробная сортировка слиянием по возрастанию  */
/*-----------------------------------------------*/
void Merge_sort_podr(int* pznachenue          // указатель на первый элемент динамического массива-вектора
	               , int begin                // начало динамического массива-вектора
	               , int end                  // конец динамического массива-вектора
	               , int number)              // длина динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
{
	int i;                                    // для прохода по подмассиву
	int middle = (begin + end) / 2;           // отталкиваться будем от середины каждой части, разделяя массив на 2 подмассива
	// если осталось по одному элементу в каждом подмассиве
	// базовое условие
	if (begin >= end)
	{
		// выводим, когда в каждой части по одному элементу
		// выводим левые части
		if (begin == 0)
		{
			// идем по левому подмассиву
			for (i = begin; i <= end; i++)
			{
				// подкрашиваем его середину
				if (i == middle)
				{
					cout << "\x1b[31m" << pznachenue[i] << " \x1b[30m";
				}
				// остальные-просто выводим 
				else
				{
					cout << pznachenue[i] << " ";
				}
			}// for i
			cout << " ";
		}// if (begin == 0) 

		// выводим правые части
		else if (begin != 0)
		{
			// идем по правому подмассиву
			for (i = begin; i <= end; i++)
			{
				// подкрашиваем его середину
				if (i == middle)
				{
					cout << "\x1b[31m" << pznachenue[i] << " \x1b[30m";
				}
				// остальные-просто выводим 
				else
				{
					cout << " " << pznachenue[i] << " ";
				}// if (i == middle)
			}// for i
			cout << "\n";
		}// else if (begin != 0)
		return;                     // вернулись на шаг назад в caller, где в рассматриваемой части 2 элемента минимум
	}// if(begin >= end)

	// кода в каждой части не по одному элементу
	// выводим левые части
	if (begin == 0)
	{
		// идем по левому подмассиву
		for (i = begin; i <= end; i++)
		{
			// подкрашиваем его середину
			if (i == middle)
			{
				cout << "\x1b[31m" << pznachenue[i] << " \x1b[30m";
			}
			// остальные-просто выводим
			else
			{
				cout << pznachenue[i] << " ";
			}// if (i == middle)
		}// for i
		cout << "\n";
	}// if (begin == 0)

	else if (begin != 0)
	{
		// идем по левому подмассиву
		for (i = begin; i <= end; i++)
		{
			// подкрашиваем его середину
			if (i == middle)
			{
				cout << "\x1b[31m" << pznachenue[i] << " \x1b[30m";
			}
			// остальные-просто выводим
			else
			{
				cout << " " << pznachenue[i] << " ";
			}// if (i == middle)
		}// for i
		cout << "\n";
	}//else if (begin != 0)
	Merge_sort_podr(pznachenue, begin, middle, number);    // сортировка левой части
	Merge_sort_podr(pznachenue, middle + 1, end, number);  // сортировка правой части
	Merge_podr(pznachenue, begin, middle, end);            // слияние двух частей
	if (begin == 0 && end == number - 1)
	{
		cout << "\n\x1b[31mПросуммируйте все сравнения и пересылки, чтобы получить общее их количество\x1b[30m \n";
	}
}// Merge_sort_podr()


/*----------------------------------------------------------------------------------*/
/* "Влавствование" - сливание массивов для Merge_podr     */
/*--------------------------------------------------------*/
void Merge_podr(int* pznachenue               // указатель на первый элемент динамического массива-вектора
	          , int begin                     // начало динамического массива-вектора
	          , int middle                    // середина динамического массива-вектора
	          , int end)                      // конец динамического массива-вектора
{
	// соединение начинается с самых маленьких подмассивов в порядке рекурсии
	cout << "Склеиваем: ";
	int sravnenue;                            // число необходимых сравнений
	int peresulka;                            // число пересылок
	int i;                                    // для цикла
	int j;                                    // для цикла
	int k;                                    // для цикла

	sravnenue = 0;                            // изначально ничего не сравниваем
	peresulka = 0;                            // изначально нет пересылок
	int dlB = middle - begin + 1;             // длина левой части подмассива
	int dlC = end - middle;                   // длина правой части подмассива
	int* B = NULL;                            // объявляем указатель на динамический массив элементов левой части. Инициализируем его, чтобы не был диким
	B = new int[dlB + 1];                     // создаём динамический подмассив, хранящий элементы левой части исходного
	int* C = NULL;                            // объявляем указатель на динамический массив элементов правой части. Инициализируем его, чтобы не был диким
	C = new int[dlC + 1];                     // создаём динамический подмассив, хранящий элементы правой части исходного
	// заполняем левую часть
	// для B выделено j, т.к не обязательно begin=0
	j = 0;                                    // начинаем заполнять с 0
	for (i = begin; i <= middle; i++)
	{
		B[j] = pznachenue[i];                 // элемент левой части - элемент переданного подмассива 
		j++;                                  // перемещаемся по подмассиву
	}// for i
	j = 0;                                    // обнулили счётчик для работы с подмассивом C

	// заполняем правую часть
	// для C выделено j, т.к  middle+1!=0
	for (i = middle + 1; i <= end; i++)
	{
		C[j] = pznachenue[i];                 // элемент правой части - элемент переданного подмассива 
		j++;                                  // перемещаемся по подмассиву
	}// for i

	B[dlB] = INT_MAX;                         // на последнее место каждого массива ставим заведомо больший элемент,
	C[dlC] = INT_MAX;                         // чтобы не допускать выхода за пределы массива
	i = 0;                                    // ставим все счётчики в начало массивов
	j = 0;
	for (k = begin; k <= end; k++)            // идём по подмассиву
	{
		// выстраиваем иерархию элементов правой и левой части
		if (B[i] <= C[j])                     // если элемент правой части больше или равен элементу левой части 
		{
			// увеличили число сравнений
			sravnenue = sravnenue + 1;
			// если элемент в массиве стоял не не своём месте
			if (B[i] != pznachenue[k])
			{
				// увеличили количество пересылок
				peresulka = peresulka + 1;
			}// if(B[i]!= pznachenue[k]);
			pznachenue[k] = B[i];             // помещаем элемент из левой части на текущее место подмассива
			i = i + 1;                        // перешли к следующему элементу левой части
			// если будет INT_MAX, то левая часть выходит из рассмотрения
		}
		else                                // если элемент левой части больше элемента правой части
		{
			// увеличили число сравнений
			sravnenue = sravnenue + 1;
			// если элемент в массиве стоял не не своём месте
			if (C[j] != pznachenue[k])
			{
				// увеличили количество пересылок
				peresulka = peresulka + 1;
			}// if(C[j]!= pznachenue[k]);
			pznachenue[k] = C[j];           // помещаем элемент из правой части на текущее место подмассива
			j = j + 1;                      // перешли к следующему элементу правой части
			// если будет INT_MAX, то правая часть выходит из рассмотрения
		}// if (B[i] <= C[j])
	}// for k
	// выводим подмассив после слияния
	for (i = begin; i <= end; i++)
	{
		cout << pznachenue[i] << " ";
	}// for i
	cout << "\n";
	cout << "Количество сравнений: " << sravnenue << endl;
	cout << "Количество пересылок: " << peresulka << endl << endl;
	delete[]B;                              // подмассивы отработаны - уничтожаем их
	delete[]C;
	return;                                 // вернули обещанное значение в caller
}// Merge_podr()


/*-----------------------------------------------------------*/
/*  подробная быстрая сортировка по возрастанию */
/*----------------------------------------------*/
void Quick_sort_podr(int* pznachenue        // указатель на первый элемент динамического массива-вектора
	               , int begin              // начало динамического массива-вектора
	               , int end                // конец динамического массива-вектора
	               , int number)            // длина динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в 
{
	int i;                                  // для прохода по элементам подмассива
	int middle;                             // для элемента отталкивания

	// если осталось по одному элементу в каждом подмассиве
	// базовое условие
	if (begin >= end)
	{
		// когда в очередной части дошли до предела разбития
		if (begin > end)
		{
			cout << "Изменяем массив на основании разбития по опорным: ";
			// выводим массив после очередного изменения
			for (i = 0; i < number; i++)
			{
				cout << pznachenue[i] << " ";
			}
			cout << "\n";
		}// if (begin > end)
		return;               // вернулись на шаг назад в caller, где в рассматриваемой части 2 элемента минимум
	}//if (begin >= end)
	// переставляем элементы по оси
	middle = Partition_podr(pznachenue, begin, end);
	// работаем с подмассивом, содержащем элементы, меньшие опорной точки
	Quick_sort_podr(pznachenue, begin, middle - 1, number);
	// работаем с подмассивом, содержащем элементы, превышающие точку опоры
	Quick_sort_podr(pznachenue, middle + 1, end, number);
	if (begin == 0 && end == number-1)
	{
		cout << "\n\x1b[31mПросуммируйте все сравнения и пересылки, чтобы получить общее их количество\x1b[30m \n";
	}
}// Quick_sort_vozr()


/*----------------------------------------------------------------------------*/
/*   разделение и перестановка для Quick_sort_podr        */
/*--------------------------------------------------------*/
int Partition_podr(int* pznachenue            // указатель на первый элемент динамического массива-вектора
	             , int begin                  // начало динамического массива-вектора
	             , int end)                   // конец динамического массива-вектора
{	             
	// элементы, меньшие точки опоры, будут перемещены влево от index
	// элементы, большие точки опоры, будут перемещены вправо от index
	// равные элементы могут идти в любом направлении
	int sravnenue;                          // число необходимых сравнений
    int peresulka;                          // число пересылок
	int index = begin;
	int i;                                  // для циклов
	int Temp;                               // для замены

	sravnenue = 0;                          // изначально ничего не сравниваем
	peresulka = 0;                          // изначально нет пересылок  
	// идём в данном подмассиве с начала подмассива в его конец
	cout << "Выясняем, где опорный по отношению к большим/ меньшим: \n";
	for (i = begin; i <= end; i++)
	{
		// за опорный всегда берём последний элемент каждой части
		// подкрашиваем его
		if (i == end)
		{
			cout << "\x1b[31m" << pznachenue[i] << " \x1b[30m";
		}
		// все остальные - просто выводим
		else
		{
			cout << pznachenue[i] << " ";
		}// (i == end)
	}// for i
	cout << "\n";
	// идём в данном подмассиве с начала подмассива в его конец
	for (i = begin; i < end; i++)
	{
		// увеличили число сравнений
		sravnenue = sravnenue + 1;  
		// если нашли элемент, меньший или равный опорного (кравний правый)
		if (pznachenue[i] <= pznachenue[end])
		{
			// поместили элемент перед опорной точкой        
			Temp = pznachenue[i];
			pznachenue[i] = pznachenue[index];
			pznachenue[index] = Temp;
			index = index + 1;              // index увеличивается
		}// (pznachenue[i] <= pznachenue[end])
		if (pznachenue[i] > pznachenue[end])
		{
			// увеличили количество пересылок
			peresulka = peresulka + 1;
		}// if (pznachenue[i] > pznachenue[end])
	}// for i
	// поменяли местами опорный и index элементы
	if (index != end)
	{
		// увеличили количество пересылок
		peresulka = peresulka + 1;
	}//if (index != end)
	Temp = pznachenue[end];
	pznachenue[end] = pznachenue[index];
	pznachenue[index] = Temp;
	cout << "Переместили опорный: ";
	// выводим массив после выяснения положения опорного элемента
	for (i = begin; i <= end; i++)
	{
		// наткнулись на опорный
		// подкрасили его
		if (i == index)
		{
			cout << "\x1b[31m" << pznachenue[i] << " \x1b[30m";
		}
		// все остальные просто выводим
		else
		{
			cout << pznachenue[i] << " ";
		}// if (i == index)
	}// for i
	cout << "\n";
	cout << "Количество сравнений: " << sravnenue << endl;
	cout << "Количество пересылок: " << peresulka << endl << endl;
	return(index);                         // вернули индекс опорного элемента в caller
}//Partition_podr()


/*-----------------------------------------------------------*/
/*   подробная сортировка Шелла по возрастанию */
/*---------------------------------------------*/
void Shell_sort_podr(int* pznachenue        // указатель на первый элемент динамического массива-вектора
	               , int begin              // начало динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	               , int end                // конец динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	               , int number)            // длина динамического массива-вектора
{
	int sravnenue;                          // число необходимых сравнений
	int peresulka;                          // число пересылок
	int i;                                  // для цикла
	int j;                                  // для цикла
	int k;                                  // для печати массива
	int Temp;                               // для замены
	int d;                                  // ширина интервала

	sravnenue = 0;                          // изначально ничего не сравниваем
	peresulka = 0;                          // изначально нет пересылок
	d = number / 2;                         // изначально ширина между элементами одной группы - половина массива
	// рассматриваем каждый раз элементы через уменбшающиеся интеравалы, пока не дойдём до рассмотрения каждого друг с другом
	while (d > 0)
	{
		cout << "\nРазбили массив на меньшие части: \n";
		for (i = 0; i < number - d; i++)    // идём по количеству пар
		{
			j = i;                          // пары начинаем с конца рассматриваемой части
			// будем идти с увеличением i по каждой паре, захватывая всё большее количество элементов
			while (j >= 0)
			{
				sravnenue = sravnenue + 1;  // увеличили число сравнений
				// печатаем один раз без ненужных повторений
				if (i == j)
				{   // печать массива
					for (k = 0; k < number; k++)
					{
						// если элементы находятся на одной ширине
						// подкрашиваем их
						if ((k - j) % d == 0)
						{
							cout << "\x1b[31m" << pznachenue[k] << " \x1b[30m";
						}
						// остальные просто выводим
						else
						{
							cout << pznachenue[k] << " ";
						}// if ((k - j) % d == 0)
					}// for k
					cout << "\n";
					// опять идём по массиву и выделяем сравнивающиеся элементы в пределах одной пары
					for (k = 0; k < number; k++)
					{
						// выделяем сравнивающиеся элементы первой половины подмассива
						if ((k == j || k == j + d) && ((k - j) % d == 0))
						{
							cout << "\x1b[36m" << pznachenue[k] << " \x1b[30m";
						}
						// элементы, находящиеся на такой же ширине подкрашиваем красным
						else if ((k != j && k != j + d) && ((k - j) % d == 0))
						{
							cout << "\x1b[31m" << pznachenue[k] << " \x1b[30m";
						}
						// остальные элементы массива просто выводим
						else
						{
							cout << pznachenue[k] << " ";
						}// ((k == j || k == j + d) && ((k - j) % d ==0))
					}// for k
					cout << "\n";
				}// if (i==j)
				if (pznachenue[j] > pznachenue[j + d])  // рассматриваем текущий и следующий в интеравале
				{
					peresulka = peresulka + 1;          // увеличили количество пересылок
					// если текущий элемент, больше следующего из этого интевала
					// меняем местами
					Temp = pznachenue[j];
					pznachenue[j] = pznachenue[j + d];
					pznachenue[j + d] = Temp;
				}// if (pznachenue[j] > pznachenue[j + d])
				j--; // верулись к предыдущему, идем с шагом назад
			}// while j
		}// for i
		d = d / 2;   // уменьшили интервал
	}// while d
	cout << "Количество сравнений: " << sravnenue << endl;
	cout << "Количество пересылок: " << peresulka << endl;
	return;                                  // вернули обещанное значение в caller
}// Shell_sort_podr()

