#include <iostream>           // стандартные потоки ввода/вывода
#include <fstream>            // файловые потоки ввода/вывода
#include <iomanip>            // библиотека с модификатором setw
#include <time.h>             // библиотека с модификатором srand
#include <chrono>             // подключение библиотеки для вычисления времени работы алгоритмов 
#include "Promeg_functions.h" // подключаем заголовочный файл с прототипами вспомогательных функций 
#include "Constants.h"        // подключаем заголовочный файл с глобальными константами
#include "Sort_vozr.h"        // подключаем заголовочный файл с прототипами алгоритмов сортировки по возрастанию
#include "Sort_ub.h"          // подключаем заголовочный файл с прототипами алгоритмов сортировки по убыванию
#include "Sort_podr.h"        // подключаем заголовочный файл с прототипами подробных алгоритмов сортировки по возрастанию

using namespace std;    // используем пространство имён std
/***************************************************/
/*             РЕАЛИЗАЦИЯ ФУНКЦИЙ                  */
/***************************************************/

/*-----------------------------------------------------------*/
/* печать условий для выбора функции */
/*-----------------------------------*/
void pechatusloviy()
{
	// Выводим условия в таблице
	setlocale(0, "C");                       // отключаем русский язык
	cout << char(218) << setw(40) << setfill((char)196) << (char)191 << endl << (char)179;  // выводим верхнюю строку шапки
	setlocale(LC_ALL, "Rus");                // подключаем русский язык
	cout << "   Выберите алгоритм сортировки:       ";
	setlocale(0, "C");                       // отключаем русский язык
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)194 << setw(35) << setfill((char)196) << (char)180 << setfill(' ') << endl << (char)179;    // выводим нижнюю строку шапки с разделителем между номером и названием алгоритма
	cout << "  1." << (char)179 << "  Shaker_sort                     ";                                                                                                         // выводим условия выбора и нижнюю с боковыми строчками таблицы
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  2." << (char)179 << "  Selection_sort                  ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  3." << (char)179 << "  Insertion_sort                  ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  4." << (char)179 << "  Merge_sort                      ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  5." << (char)179 << "  Quick_sort                      ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  6." << (char)179 << "  Shell_sort                      ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  7." << (char)179 << "  Repeat with other numbers       ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  8." << (char)179 << "  Exit.                           ";
	cout << (char)179 << endl << (char)192 << setw(5) << setfill((char)196) << (char)193 << setw(35) << setfill((char)196) << (char)217 << endl;
	setlocale(LC_ALL, "Rus");               // подключаем русский язык
	return;                                 // возвращаем обещанное значение
}// pechatusloviy()


/*-----------------------------------------------------------*/
/* печать сформированного массива в таблице */
/*------------------------------------------*/
void pechat_tabl(int* pznachenue  // указатель на первый элемент динамического массива-вектора 
	           , int number)      // количество элементов в массиве-векторе
{
	int j;                        // для прохода по элементам массива
	cout << "\t\t\t\t \x1b[33mЦ Е Л О Ч И С Л Е Н Н Ы Й   М А С С И В   З Н А Ч Е Н И Й:\x1b[30m \n";
	setlocale(0, "C");            // выводим массив в красивых скобках
	cout << (char)218 << (char)196 << (char)196 << setw(30) << setfill(' ') << (char)196 << (char)196 << (char)191;          // вывод верхних квадратных скобок
	for (j = 0; j < number; j++)  // идем по всем элементам массива, используя адресную арифметику
	{// выводим элемент массива
		cout << "\n" << char(179) << setw(17) << setfill(' ') << *(pznachenue + j) << setw(17) << setfill(' ') << char(179) << setw(6) << setfill(' ') << "n = " << j + 1;
	}// for j
	cout << '\n';
	cout << (char)192 << (char)196 << (char)196 << setw(30) << setfill(' ') << (char)196 << (char)196 << (char)217 << endl;  // вывод нижних квадратных скобок
	setlocale(LC_ALL, "Rus");     // подключаем русский язык
}//pechat_tabl()


/*-----------------------------------------------------------*/
/* создание динамического массива           */
/*------------------------------------------*/
void sozdanie(int** pznachenue    // адрес указателя на динамический массив-вектор, для изменения значения указателя
	        , int** soxranenie    // адрес указателя на динамический массив-вектор сохранения элементов исходного перед сортировкой
	        , int& number)        // количество элементов в массиве-векторе для изменения              
{
	cout << "Введите количество элементов массива: ";
	cin >> number;                // размер массива, введённый пользователем
	cout << endl;
	if (!cin.good())              // если количество элементов не число
	{// выход по ошибке
		cout << "Выбранный введённое количество элементов не является целым числом или вне диапазона!!!";
		cout << "\n\t\t\t\t\tЗ А В Е Р Ш Е Н И Е   П Р О Г Р А М М Ы \n\n";
		system("pause");
		exit(1);                  // закончили программу из функции
	}
	*pznachenue = new int[number];// для всех остальных алгоритмов создали массив на нужное количество элементов
	*soxranenie = new int[number];// создали массив для дублирования на нужное количество элементов
	return;                       // создали - вышли. Вернули обещанное значение в caller
}//sozdanie()


/*-----------------------------------------------------------*/
/*  заполнение динамическго массива - вектора  */
/*---------------------------------------------*/
void zapolnenie(int* pznachenue   // указатель на первый элемент динамического массива-вектора 
	          , int* soxranenie   // указателя на первый элемент динамического массива-вектора для копирования
	          , int number)       // количество элементов в массиве-векторе          
{
	int i;                        // для цикла заполнения
	char choice;                  // выбор, где будет находиться ключ
	cout << "Какой случай Вы хотите рассмотреть для массива? Выберете из предложенных:\n\n";
	cout << setw(41) << setfill(' ') << "A) Наилучший (массив уже отсортирован);" << setw(57) << setfill(' ') << "B) Наихудший (массив отсортирован в обратном порядке);" << setw(20) << setfill(' ') << "C) Произвольный;" << endl << endl;
	cout << "\n\x1b[31mЗАМЕЧАНИЕ:\x1b[30m в случае сортировки по убыванию A и B меняются местами\n\n";
	cout << "Введите A, B, C (Латиницей заглавными буквами): ";
	cin >> choice;                // пользователь выбрал, где будет находиться ключ
	cout << "Вы ввели: " << choice << endl << endl;  // эхо-печать

	srand(time(NULL));            // базовое значение генератора псевдослучайных чисел, чтобы rand выдавал не одно и то же значение при разных вызовах
	if (choice == 'A')            // элементы массива изначально в порядке возрастания. Лучший случай для сортировки по возрастанию, худший - для убывания
	{
		pznachenue[0] = rand() % rand_min;                   // выбрали первый элемент маленьким
		for (i = 1; i < number; i++)                         // отталкиваясь от него идём по всем элементам массива
		{
			pznachenue[i] = pznachenue[i - 1] + rand() % step; // каждый следующий больше предыдущего максимум на step
		}// for i
		copy(pznachenue, soxranenie, number);                // скопировали содержимое в массив хранения, т.к после сортировки исходный массив изменится
		return;                                              // заполнили - вернулись в caller
	}// if(choice == 'A')

	else if (choice == 'B')      // элементы массива изначально в порядке убывания. Лучший случай для сортировки по убыванию, худший - для возрастания
	{
		pznachenue[0] = rand() % rand_max;                    // выбрали первый элемент большим случайным числом
		for (i = 1; i < number; i++)                          // отталкиваясь от него идём по всем элементам массива
		{
			pznachenue[i] = pznachenue[i - 1] - rand() % step;  // каждый следующий меньше предыдущего максимум на step
		}// for i 
		copy(pznachenue, soxranenie, number);                 // скопировали содержимое в массив хранения, т.к после сортировки исходный массив изменится
		return;                                               // заполнили - вернулись в caller
	}// else if (choice == 'B')

	else if (choice == 'C')      // элементы массива изначально в случайном порядке. Средний случай для сортировки по убыванию и для возрастания
	{
		for (i = 0; i < number; i++)                          // идём по всем элементам массива
		{
			pznachenue[i] = rand() % rand_max;                // заполняем случайным числом из достаточно большого диапазона чисел
		}// for i 
		copy(pznachenue, soxranenie, number);                 // скопировали содержимое в массив хранения, т.к после сортировки исходный массив изменится
		return;                                               // заполнили - вернулись в caller
	}// else if (choice == 'C')

	// не попали ни на одно из условий выбора ---> ошибка ввода
	cout << "\t\t\t\nВы ввели символ вне диапазона выбора, когда выбирали случай представления массива!!!\n";
	udalenie(pznachenue);        // удалили ранее созданный массив 
	udalenie(soxranenie);        // удалили ранее созданный массив сохранения 
	cout << "\n\t\t\t\t\tЗ А В Е Р Ш Е Н И Е   П Р О Г Р А М М Ы \n\n";
	system("pause");
	exit(1);                     // закончили программу из функции
}// zapolnenie()


/*-----------------------------------------------------------*/
/* удаление динамического массива           */
/*------------------------------------------*/
void udalenie(int* pznachenue)                     // указатель на первый элемент динамического массива-вектора
{
	delete[] pznachenue;                           // удалили динамический массив-вектор
	return;                                        // возвращаем обещанное значение в caller
}// udalenie()


/*--------------------------------------------------------------------------------------*/
/* копирование элементов исходного массива-вектора в промежуточный */
/*-----------------------------------------------------------------*/
void copy(int* pznachenue        // указатель на первый элемент динамического массива-вектора 
	    , int* soxranenie        // указатель на первый элемент динамического массива-вектора 
	    , int number)            // количество элементов в массиве-векторе
{ 
	int i;                       // для цикла копирования
	// массивы одинаковой длины. Идём по элементам заполненного массива
	for (i = 0; i < number; i++)
	{
		soxranenie[i] = pznachenue[i];             // сохраняем элемент первого массива во второй
	}// for i
	return;                      // сохранили - вернулись в caller
}// copy()


/*--------------------------------------------------------------------------------------*/
/* обратное копирование из промежуточного массива в исходный */
/*-----------------------------------------------------------*/
void back_copy(int* pznachenue   // указатель на первый элемент динамического массива-вектора 
	         , int* soxranenie   // указатель на первый элемент динамического массива-вектора 
	         , int number)       // количество элементов в массиве-векторе
{
	int i;                       // для цикла копирования
	// массивы одинаковой длины. Идём по элементам массива сохранения
	for (i = 0; i < number; i++)
	{
		pznachenue[i] = soxranenie[i];             // сохраняем элемент второго массива в первый
	}// for i
	return;                      // сохранили - вернулись в caller
}// back_copy()


/*-----------------------------------------------------------*/
/* выбор функции из массива                 */
/*------------------------------------------*/
void(*MENU(int& vubor              // функция, выбранная пользователем
	, char pechat                  // выбор, печатать ли подробно сравнения в массиве при поиске
	, char V_or_U))                // выбор, сортировать по возрастанию или по убыванию
	(int*, int, int, int)          // спецификация параметров функции
{
	// массив указателей на чистые функции сортировки по возрастанию, соответствующий их типам и типам их параметров
	void (*functions_vozr[])(int*, int, int, int) = { Shaker_sort_vozr, Selection_sort_vozr, Insertion_sort_vozr, Merge_sort_vozr, Quick_sort_vozr, Shell_sort_vozr };
	// массив указателей на чистые функции сортировки по убыванию, соответствующий их типам и типам их параметров
	void (*functions_ub[])(int*, int, int, int) = { Shaker_sort_ub, Selection_sort_ub, Insertion_sort_ub, Merge_sort_ub, Quick_sort_ub, Shell_sort_ub };
	// массив указателей на утяжелённые выводами функции сортировки по возрастанию, соответствующий их типам и типам их параметров
	void (*functions_podr[])(int*, int, int, int) = { Shaker_sort_podr, Selection_sort_podr, Insertion_sort_podr, Merge_sort_podr, Quick_sort_podr, Shell_sort_podr };
	cout << "\nВыберете функцию: 1 - 8, где 7 - повторение программы с другими числами в массиве, а 8 - выход \n";
	cout << "Вы ввели: ";
	cin >> vubor;                                 // ввод выбора алгоритма поиска пользователем
	if ((vubor > 0) && (vubor < 7))               // если попали в диапазон номеров из таблицы
	{
		// пользователь не хочет выводить подробно все шаги сортировки
		if (pechat == 'N')
		{
			// пользователь хочет сортировать по возрастанию
			if (V_or_U == 'V')
			{
				return (functions_vozr[vubor - 1]); // вывели соответствующий указатель из массива, содержащего указатели на чистые функции алгоритмов сортировки по возрастанию
			}// if (V_or_U == 'V')

			// пользователь хочет сортировать по убыванию
			if (V_or_U == 'U')
			{
				return (functions_ub[vubor - 1]);   // вывели соответствующий указатель из массива, содержащего указатели на чистые функции алгоритмов сортировки по убыванию
			}// if (V_or_U == 'U')  
		}// if (pechat == 'N')

		// если пользователь хочет вывести все сравнения и поромежуточные действия
		else if (pechat == 'Y')
		{
			return (functions_podr[vubor - 1]);     // вывели соответствующий указатель из массива, содержащего указатели на утяжелённые функции сортировки
		}// else if (pechat == 'Y')
	}
	else // пользователь ввёл число вне диапазона функций из таблицы или ввёл EXIT или Repeat
	{
		return NULL;                                // нулевой указатель - сбой работы, вернули в caller
	}// if((vubor > 0) && (vubor < 7))
}// *MENU()


/*----------------------------------------------------------------------------------*/
/*  печать выбранного алгоритма сортировки на экран и в файл*/
/*----------------------------------------------------------*/
void pechat_mass_search(int* pznachenue      // указатель на первый элемент динамического массива-вектора
	                  , int  number)         // количество элементов в массиве-векторе             
{
	char pechat;                             // выбор пользователя: хочет ли он вывести подробно все шаги сортировки
	char V_or_U;                             // выбор пользователя: хочет ли он сортировать массив по возрастанию или по убыванию
	int vubor = 0;                           // номер функции, выбранной пользователем              
	int begin = 0;                           // начало динамического массива-вектора
	int end = 0;                             // конец динамического массива-вектора
	int i;                                   // для циклов
	int* soxranenie = NULL;                  // указатель на массив для сохранения элементов исходного
	void(*choiсe)(int*, int, int, int);      // указатель на функцию, выбранную пользователем
	// массив имен алгоритмов поиска для вывода в файл, чтобы не запутаться
	string name[6] = { "S h a k e r   s o r t", "S e l e c t i o n   s o r t", "I n s e r t i o n   s o r t", "M e r g e   s o r t", "Q u i c k   s o r t", "S h e l l   s o r t" };
	ofstream fout;                           // объявление объекта для потокового вывода данных в файл
	fout.open(FNAME, ios::_Nocreate);        // связываем обЪект с файлом. Открываем для чтения

	if (!fout.is_open())                     // файл не найден
	{
		cout << "Файла с таким именем нет. Невозможно осуществить запись\n";
		fout.close();                        // закрыть файл для записи
		system("pause");
		return;                              // возвращаем значение, соответствующее типу в caller
	}// if(!fout.is_open())
	cout << "\t\t\t\t\x1b[35mОПРЕДЕЛИМСЯ С КОЛИЧЕСТВОМ ЭЛЕМЕНТОВ В МАССИВЕ И С ВИДОМ СЛУЧАЯ\x1b[30m\n\n";
	sozdanie(&pznachenue, &soxranenie, number);    // создали динамические массивы с регулируемым числом элементов
	zapolnenie(pznachenue, soxranenie, number);    // заполнили динамический массив и сохранили элементы исходного                 
	system("cls");                                 // очистили экран - перешли к основной программе
	while (1)                                      // бесконечный цикл выбора до момента пока пользователь не выберет Exit или не ошибётся.
	{
		end = number - 1;                          // изначально конец массива - его последний элемент
		cout << "\t\t\t\t \x1b[34mР А Б О Т А   С   А Л Г О Р И Т М А М И   С О Р Т И Р О В К И\x1b[30m\n\n";
		cout << "Количество элементов в массиве : " << number << endl;  // эхо-печать
		pechatusloviy();                           // вывод функции печати условий
		cout << "\nХотите ли Вы вывести подробно все шаги сортировки? Подробная сортировка ТОЛЬКО по возрастанию! Введите Y или N: ";
		cin >> pechat;                             // ввод, хочет ли пользователь вывести подробно все шаги сортировки
		cout << "Вы ввели: " << pechat << endl;          // эхо-печать
		if (!((pechat == 'Y') || (pechat == 'N')) != 0)  // если он ввёл не тот символ
		{
			cout << "Выберите Y или N. Латиницей заглавными буквами\n";
			system("pause");
			system("cls");                               // для каждой новой функции чистим экран
			continue;                                    // запускаем выбор заново
			// копировать элементы обратно не нужно, т.к массив ещё не сортировался
		}// if(!((pechat == 'Y') || (pechat == 'N')) != 0)

		cout << "\nВ каком порядке хотите сортировать? Введите V(по возрастанию) или U(по убыванию): ";
		cin >> V_or_U;                                   // ввод, хочет ли пользователь сортировать массив по возрастанию или по убыванию
		cout << "Вы ввели: " << V_or_U << endl;          // эхо-печать
		if (!((V_or_U == 'V') || (V_or_U == 'U')) != 0)  // если он ввёл не тот символ
		{
			cout << "Выберите V или U. Латиницей заглавными буквами\n";
			system("pause");
			system("cls");                               // для каждой новой функции чистим экран
			continue;                                    // запускаем цикл заново
			// копировать элементы обратно не нужно, т.к массив ещё не сортировался
		}// if(!((pechat == 'Y') || (pechat == 'N')) != 0)

		choiсe = MENU(vubor, pechat, V_or_U);            // присваиваем указателю функцию из массива, выбранную пользователем
		if (choiсe == NULL)                              // если вышли за рамки диапазона допустимого Exit или Repeat
		{
			if (vubor == 7)                              // если пользователь выбрал Repeat
			{
				cout << "\t\t\t\t\t\x1b[31mНачинаем построение массива с другими числами!!!\x1b[30m\n\n";
				system("pause");
				system("cls");                           // чистим экран
				udalenie(pznachenue);                    // удаляем ранее созданные массивы
				udalenie(soxranenie);
				cout << "\t\t\t\t\x1b[35mОПРЕДЕЛИМСЯ С КОЛИЧЕСТВОМ ЭЛЕМЕНТОВ В МАССИВЕ И С ВИДОМ СЛУЧАЯ\x1b[30m\n\n";
				sozdanie(&pznachenue, &soxranenie, number);    // создали динамический массив с регулируемым числом элементов заново
				zapolnenie(pznachenue, soxranenie, number);     // заполнили динамический массив заново и сохранили элементы
				system("cls");                                  // перешли опять к основной программе
				continue;                                       // запускаем цикл заново  
				// копировать элементы обратно не нужно, т.к массив ещё не сортировался
			}//if (vubor == 7)

			cout << "\t\t\t\t\tЗ А В Е Р Ш Е Н И Е   П Р О Г Р А М М Ы \n\n";
			// если пользователь вёл Exit или ошибся
			system("pause");
			break;                                               // закончили цикл
		}// if (choiсe == NULL) 
		pechat_tabl(pznachenue, number);                         // распечатали заполненный массив в скобках
		cout << "\t\t\t\t\t\x1b[32mА Л Г О Р И Т М   " << name[vubor - 1] << "\x1b[30m" << endl;      // выводим название алгоритма из массива
		if (pechat == 'N')                               // если пользователь не хочет выводить подробно все шаги сортировки
		{
			auto start = chrono::steady_clock::now();    // начали отсчитывать время работы, т.к. алгоритм чистый
			choiсe(pznachenue, begin, end, number);      // вызвали функцию, выбранную из массива через указатель
			auto end = chrono::steady_clock::now();      // закончили отсчитывать время работы
			cout << "\n\n\t\t\t\t\t\t\x1b[33mО Т С О Р Т И Р О В А Н Н Ы Й\x1b[30m \n\n";
			pechat_tabl(pznachenue, number);             // распечатали его в скобках после сортировки
			fout << "\t\t\t" << name[vubor - 1] << endl; // выводим в файл имя выбранного алгоритма
			cout << "Время выполнения функции, формирующей алгоритм = " << chrono::duration_cast<chrono::microseconds>(end - start).count() << "  микросекунд; \n\n";        // выводим на экран время работы
			fout << "Время выполнения функции, формирующей алгоритм = " << chrono::duration_cast<chrono::microseconds>(end - start).count() << "  микросекунд; \n\n";        // выводим в файл время работы
		} // if (pechat == 'N')
		else if (pechat == 'Y')                          // если пользователь  хочет выводить подробно все шаги сортировки    
		{
			if (V_or_U == 'U')                           // если пользователь выбрал в подробной сортировке сортировать по убыванию
			{
				cout << "Нельзя в подробной сортировке использовать убывание!!!!\n";
				system("pause");
				system("cls");
				continue;                                // запускаем цикл заново  
				// копировать элементы обратно не нужно, т.к массив ещё не сортировался
			}// if (V_or_U == 'U')
			// если в подробной сортировке пользователь сортирует массив по возрастанию
			choiсe(pznachenue, begin, end, number);      // вызвали функцию, выбранную из массива через указатель
			cout << "\n\n\t\t\t\t\t\t\x1b[33mО Т С О Р Т И Р О В А Н Н Ы Й\x1b[30m \n\n";
			pechat_tabl(pznachenue, number);             // распечатали его в скобках после сортировки
		}// else if (pechat == 'Y')
		// если отсортировался массив
		back_copy(pznachenue, soxranenie, number);       // вернули массив обратно, т.к. он изменился после сортировки
		system("pause");
		system("cls");                                   // для каждой новой функции чистим экран
	}// while
	udalenie(soxranenie);
	udalenie(pznachenue);                                // отработали - сделали всё, что хочет пользователь. Удалили ненужнгые массивы
	fout.close();                                        // закрыть файл для записи
	return;                                              // возвращаем значение, соответствующее типу в caller
}// pechat_mass_search()