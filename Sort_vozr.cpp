#include "Sort_vozr.h"; // подключаем заголовочный файл с прототипами алгоритмов сортировки по возрастанию
#include <iostream>     // стандартные потоки ввода/вывода
// в такой реализации Quick_sort даёт переполнение стека из-за глубины рекурсии. Увеличиваем его размер
#pragma comment(linker, "/STACK:28666777216")

/***************************************************/
/*             РЕАЛИЗАЦИЯ ФУНКЦИЙ                  */
/***************************************************/

// СОРТИРОВКИ МАССИВА ПО ВОЗРАСТАНИЮ:
/*-----------------------------------------------------------*/
/* Шейкерная сортировка по возрастанию         */
/*--------------------------------------------*/
void Shaker_sort_vozr(int* pznachenue      // указатель на первый элемент динамическогомассива-вектора
	                , int begin            // начало динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	                , int end              // конец динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	                , int number)          // длина динамического массива-вектора
{
	int i;                                 // для прохода по всем элементам массива
	int Temp;                              // для промежуточного сохранения элемента замены
	// пока массив не <схлопнулся>
	while (begin <= end)
	{
		// проходим по неотсортированной части из начала в конец
		for (i = begin; i < end; i++)
		{
			if (pznachenue[i] > pznachenue[i + 1])  // если текущий больше следующего
			{
				// перемещаем его на позицию следующего
				Temp = pznachenue[i + 1];             // сохраняем следующий в промежуточную переменную
				pznachenue[i + 1] = pznachenue[i];    // помещаем на его место текущий элемент
				pznachenue[i] = Temp;                 // на место текущего: значение меньшего-сохранённого
				// далее опять сравниваем заменённый со следующим
			}// if (pznachenue[i] > pznachenue[i + 1])
		}// for i
		end = end - 1;          // самый большой элемент массива встал на своё место --> уменьшаем рассматриваемый диапазон. Сдвигаем конец

		// проходим по неотсортированной части из конца в начало.
		for (i = end; i > begin; i--)
		{
			if (pznachenue[i] < pznachenue[i - 1]) // если текущий меньше предыдущего
			{
				Temp = pznachenue[i - 1];          // сохраняем предыдущий в промежуточную переменную
				pznachenue[i - 1] = pznachenue[i]; // помещаем на его место текущий элемент
				pznachenue[i] = Temp;              // на место текущего: значение большего-сохранённого
			}// if (pznachenue[i] < pznachenue[i - 1])
		}// for i
		begin = begin + 1;      // самый маленький элемент массива встал на своё место --> уменьшаем рассматриваемый диапазон. Сдвигаем начало
	}// while (begin <= end)
	return;                                         // возвращаем обещанное значение в caller
}// Shaker_sort_vozr()


/*-----------------------------------------------------------*/
/* сортировка выбором  по возрастанию         */
/*--------------------------------------------*/
void Selection_sort_vozr(int* pznachenue   // указатель на первый элемент динамического массива-вектора
	                   , int begin         // начало динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	                   , int end           // конец динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	                   , int number)       // длина динамического массива-вектора
{
	int Min;                                // минимальный элемент
	int jMin;                               // индекс минимального элемента
	int iSort;                              // граница отсортированной области
	int i, j;                               // счётчики
	int Temp;                               // для обмена

	for (iSort = 0; iSort < number - 1; iSort++)   // пока не дошли до конца
	{
		// первый элемент из неупорядоченных назначаем минимальным. С УЧЁТОМ ПЕРЕДАЧИ АДРЕСА на первый элемент в функцию
		Min = *(pznachenue + iSort);               // минимум
		jMin = iSort;                              // его индекс

		// ищем минимальный элемент в оставшейся части массива
		for (j = iSort + 1; j < number; j++)
		{
			if (*(pznachenue + j) < Min)           // очередной кандидат на минимальный
			{
				// запоминаем минимальный элемент и его номер
				Min = *(pznachenue + j);
				jMin = j;
			}// if(*(pznachenue + j) < Min)
		}// for j

		// нашли минимум в неупорядоченной части массива
		// ставим его на место первого в неупорядоченной части массива
		// меняем элементы местами
		Temp = *(pznachenue + iSort);
		*(pznachenue + iSort) = *(pznachenue + jMin);
		*(pznachenue + jMin) = Temp;
	}// for iSort
	return;                                         // вернули обещанное значение в caller
}// sort()


/*-----------------------------------------------------------*/
/* сортировка вставками по возрастанию         */
/*---------------------------------------------*/
void Insertion_sort_vozr(int* pznachenue   // указатель на первый элемент динамического массива-вектора
	                   , int begin         // начало динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	                   , int end           // конец динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	                   , int number)       // длина динамического массива-вектора          
{
	int i;                                 // для прохода в цикле
	int key;                               // для хранения перемещаемого элемента
	int j;                                 // для прохода в цикле
	// идём с начала до конца
	for (i = 1; i < number; i++)
	{
		key = pznachenue[i];               // запоминаем элемент, который будем перемещать
		j = i - 1;                         // работаем с той частью, которая находится до перемещаемого элемента
		// идём по этой части с конца в начало - перемещаем элементы в соответствии с их отношением к ключу
		// если в части до ключа элементы, большие его
		while (j >= 0 && pznachenue[j] > key)
		{
			// сдвигаем элементы до тех пор, пока следующий не будет меньше ключа
			// ставим на место следующего элемента(для конца части - на место первого) элемент, больший ключа
			pznachenue[j + 1] = pznachenue[j];
			j = j - 1;                     // сдвигаемся по части, находящейся до ключа
		}// while (j >= 0 && pznachenue[j] > key)
		pznachenue[j + 1] = key;           // ставим на новое место запомненный элемент - ключ
	}// for i
	return;                                // вернули обещанное значение в caller
}// Insertion_sort_vozr()


/*-----------------------------------------------------------*/
/* сортировка слиянием по возрастанию          */
/*---------------------------------------------*/
void Merge_sort_vozr(int* pznachenue       // указатель на первый элемент динамического массива-вектора
	               , int begin             // начало динамического массива-вектора
	               , int end               // конец динамического массива-вектора
	               , int number)           // длина динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
{
	int middle;                            // отталкиваться будем от середины каждой части, разделяя массив на 2 подмассива
	// если осталось по одному элементу в каждом подмассиве
	// базовое условие
	if (begin >= end)
	{
		return;                            // вернулись на шаг назад в caller, где в рассматриваемой части 2 элемента минимум
	}// if(begin >= end)
	middle = (begin + end) / 2;            // вычислили средний элемент для текущего подмассива
	Merge_sort_vozr(pznachenue, begin, middle, number);  // сортировка левой части
	Merge_sort_vozr(pznachenue, middle + 1, end, number); // сортировка правой части
	Merge_vozr(pznachenue, begin, middle, end);          // слияние двух частей
}// Merge_sort_vozr()


/*----------------------------------------------------------------------------------*/
/* "Влавствование" - сливание массивов для Merge_sort_vozr         */
/*-----------------------------------------------------------------*/
void Merge_vozr(int* pznachenue            // указатель на первый элемент динамического массива-вектора
	          , int begin                  // начало динамического массива-вектора
	          , int middle                 // середина динамического массива-вектора
	          , int end)                   // конец динамического массива-вектора
{
	// соединение начинается с самых маленьких подмассивов в порядке рекурсии
	int i;                                 // для цикла
	int j;                                 // для цикла
	int k;                                 // для цикла
	int dlB = middle - begin + 1;          // длина левой части подмассива
	int dlC = end - middle;                // длина правой части подмассива
	int* B = NULL;                         // объявляем указатель на динамический массив элементов левой части. Инициализируем его, чтобы не был диким             
	B = new int[dlB + 1];                  // создаём динамический подмассив, хранящий элементы левой части исходного
	int* C = NULL;                         // объявляем указатель на динамический массив элементов правой части. Инициализируем его, чтобы не был диким
	C = new int[dlC + 1];                  // создаём динамический подмассив, хранящий элементы правой части исходного
	// заполняем левую часть
	// для B выделено j, т.к не обязательно begin=0
	j = 0;                                 // начинаем заполнять с 0;
	for (i = begin; i <= middle; i++)
	{
		B[j] = pznachenue[i];              // элемент левой части - элемент переданного подмассива 
		j++;                               // перемещаемся по подмассиву
	}// for i
	j = 0;                                 // обнулили счётчик для работы с подмассивом C

	// заполняем правую часть
	// для C выделено j, т.к  middle+1!=0
	for (i = middle + 1; i <= end; i++)
	{
		C[j] = pznachenue[i];               // элемент правой части - элемент переданного подмассива 
		j++;                                // перемещаемся по подмассиву
	}// for i

	B[dlB] = INT_MAX;                       // на последнее место каждого массива ставим заведомо больший элемент,
	C[dlC] = INT_MAX;                       // чтобы не допускать выхода за пределы массива
	i = 0;                                  // ставим все счётчики в начало массивов
	j = 0;
	for (k = begin; k <= end; k++)          // идём по подмассиву
	{
		// выстраиваем иерархию элементов правой и левой части
		if (B[i] <= C[j])                   // если элемент правой части больше или равен элементу левой части 
		{
			pznachenue[k] = B[i];           // помещаем элемент из левой части на текущее место подмассива
			i = i + 1;                      // перешли к следующему элементу левой части
			// если будет INT_MAX, то левая часть выходит из рассмотрения
		}
		else                                // если элемент левой части больше элемента правой части
		{
			pznachenue[k] = C[j];           // помещаем элемент из правой части на текущее место подмассива
			j = j + 1;                      // перешли к следующему элементу правой части
			// если будет INT_MAX, то правая часть выходит из рассмотрения
		}// if (B[i] <= C[j])
	}// for k
	delete[]B;                              // подмассивы отработаны - уничтожаем их
	delete[]C;
	return;                                 // вернули обещанное значение в caller
}// Merge_vozr()


/*-----------------------------------------------------------*/
/*   быстрая сортировка по возрастанию         */
/*---------------------------------------------*/
void Quick_sort_vozr(int* pznachenue        // указатель на первый элемент динамического массива-вектора
	               , int begin              // начало динамического массива-вектора
	               , int end                // конец динамического массива-вектора
	               , int number)            // длина динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
{
	int middle;                             // для элемента отталкивания
	// если осталось по одному элементу в каждом подмассиве
	// базовое условие
	if (begin >= end)
	{
		return;                             // вернулись на шаг назад в caller, где в рассматриваемой части 2 элемента минимум
	}
	// переставляем элементы по оси
	middle = Partition_vozr(pznachenue, begin, end);
	// работаем с подмассивом, содержащем элементы, меньшие опорной точки
	Quick_sort_vozr(pznachenue, begin, middle - 1, number);
	// работаем с подмассивом, содержащем элементы, превышающие точку опоры
	Quick_sort_vozr(pznachenue, middle + 1, end, number);
}// Quick_sort_vozr()


/*----------------------------------------------------------------------------*/
/*   разделение и перестановка для Quick_sort_vozr        */
/*--------------------------------------------------------*/
int Partition_vozr(int* pznachenue         // указатель на первый элемент динамического массива-вектора
	             , int begin               // начало динамического массива-вектора
	             , int end)                // конец динамического массива-вектора
{
	// элементы, меньшие точки опоры, будут перемещены влево от index
	// элементы, большие точки опоры, будут перемещены вправо от index
	// равные элементы могут идти в любом направлении
	int index = begin;
	int i;                                  // для циклов
	int Temp;                               // для замены
	// идём в данном подмассиве с начала подмассива в его конец
	for (i = begin; i < end; i++)
	{
		// если нашли элемент, меньший или равный опорного (кравний правый)
		if (pznachenue[i] <= pznachenue[end])
		{
			// поместили элемент перед опорной точкой
			Temp = pznachenue[i];
			pznachenue[i] = pznachenue[index];
			pznachenue[index] = Temp;
			index = index + 1;              // index увеличивается
		}// (pznachenue[i] <= pznachenue[end])
	}// for i
	// поменяли местами опорный и index элементы
	Temp = pznachenue[end];
	pznachenue[end] = pznachenue[index];
	pznachenue[index] = Temp;
	return(index);                          // вернули индекс опорного элемента в caller
}// Partition_vozr()


/*-----------------------------------------------------------*/
/*   сортировка Шелла по возрастанию           */
/*---------------------------------------------*/
void Shell_sort_vozr(int* pznachenue        // указатель на первый элемент динамического массива-вектора
	               , int begin              // начало динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	               , int end                // конец динамического массива-вектора (не нужно фактически). Поставлено, чтобы все функции были в одном массиве
	               , int number)            // длина динамического массива-вектора
{
	int i;                                  // для цикла
	int j;                                  // для цикла
	int Temp;                               // для замены
	int d;                                  // ширина интервала
	d = number / 2;                         // изначально ширина между элементами одной группы - половина массива
	// рассматриваем каждый раз элементы через уменбшающиеся интеравалы, пока не дойдём до рассмотрения каждого друг с другом
	while (d > 0)
	{
		for (i = 0; i < number - d; i++)    // идём по количеству пар
		{
			j = i;                          // пары начинаем с конца рассматриваемой части
			// будем идти с увеличением i по каждой паре, захватывая всё большее количество элементов
			while (j >= 0)                  // пока не дойдём до начала
			{
				if (pznachenue[j] > pznachenue[j + d])  // рассматриваем текущий и следующий в интеравале
				{
					// если текущий элемент, больше следующего из этого интевала
					// меняем местами
					Temp = pznachenue[j];
					pznachenue[j] = pznachenue[j + d];
					pznachenue[j + d] = Temp;
				}// if (pznachenue[j] > pznachenue[j + d])
				j--; // верулись к предыдущему, идем с шагом назад
			}// while j
		}// for i
		d = d / 2;   // уменьшили интервал
	}// while d
	return;                                  // вернули обещанное значение в caller
}// Shell_sort_vozr()
